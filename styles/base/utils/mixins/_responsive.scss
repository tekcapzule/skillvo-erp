/**
 * Responsive Mixins
 * Version: 1.0.0
 * Last Updated: 2024-06-28
 * 
 * This file contains mixins for handling responsive breakpoints
 * in the SkillVo design system.
 */

@use 'sass:map';
@use './../../../abstracts/variables/breakpoints' as *;  // Import the breakpoints file

/* Min-width breakpoint (from this size and up) */
@mixin breakpoint-up($breakpoint) {
  @if map.has-key($breakpoints, $breakpoint) {
    @media (min-width: map.get($breakpoints, $breakpoint)) {
      @content;
    }
  } @else {
    @error "Unknown breakpoint `#{$breakpoint}`. Available breakpoints: #{map.keys($breakpoints)}";
  }
}

/* Max-width breakpoint (from this size and down) */
@mixin breakpoint-down($breakpoint) {
  @if map.has-key($breakpoints, $breakpoint) {
    @media (max-width: (map.get($breakpoints, $breakpoint) - 0.02px)) {
      @content;
    }
  } @else {
    @error "Unknown breakpoint `#{$breakpoint}`. Available breakpoints: #{map.keys($breakpoints)}";
  }
}

/* Between two breakpoints (inclusive) */
@mixin breakpoint-between($lower, $upper) {
  @if map.has-key($breakpoints, $lower) and map.has-key($breakpoints, $upper) {
    @media (min-width: map.get($breakpoints, $lower)) and (max-width: (map.get($breakpoints, $upper) - 0.02px)) {
      @content;
    }
  } @else {
    @error "Unknown breakpoint `#{$lower}` or `#{$upper}`. Available breakpoints: #{map.keys($breakpoints)}";
  }
}

/* Only at a specific breakpoint */
@mixin breakpoint-only($breakpoint) {
  @if map.has-key($breakpoints, $breakpoint) {
    $lower: map.get($breakpoints, $breakpoint);
    $upper: if(
      map.has-key($breakpoints, breakpoint-next($breakpoint)),
      map.get($breakpoints, breakpoint-next($breakpoint)),
      null
    );
    
    @if $upper {
      @media (min-width: $lower) and (max-width: ($upper - 0.02px)) {
        @content;
      }
    } @else {
      @media (min-width: $lower) {
        @content;
      }
    }
  } @else {
    @error "Unknown breakpoint `#{$breakpoint}`. Available breakpoints: #{map.keys($breakpoints)}";
  }
}

/* Get the next breakpoint name */
@function breakpoint-next($breakpoint) {
  $breakpoint-list: map.keys($breakpoints);
  $index: index($breakpoint-list, $breakpoint);

  @if $index and $index < length($breakpoint-list) {
    @return nth($breakpoint-list, $index + 1);
  } @else {
    @return null;
  }
}

/* Mobile-first responsive padding */
@mixin responsive-padding($property, $mobile, $tablet: null, $desktop: null, $large: null) {
  #{$property}: $mobile;
  
  @if $tablet {
    @include responsive.breakpoint-up('md') {
      #{$property}: $tablet;
    }
  }
  
  @if $desktop {
    @include responsive.breakpoint-up('lg') {
      #{$property}: $desktop;
    }
  }
  
  @if $large {
    @include responsive.breakpoint-up('xl') {
      #{$property}: $large;
    }
  }
}

/* Mobile-first responsive margin */
@mixin responsive-margin($property, $mobile, $tablet: null, $desktop: null, $large: null) {
  #{$property}: $mobile;
  
  @if $tablet {
    @include responsive.breakpoint-up('md') {
      #{$property}: $tablet;
    }
  }
  
  @if $desktop {
    @include responsive.breakpoint-up('lg') {
      #{$property}: $desktop;
    }
  }
  
  @if $large {
    @include responsive.breakpoint-up('xl') {
      #{$property}: $large;
    }
  }
}

/* Hide content based on viewport */
@mixin hide-on($breakpoint, $direction: 'down') {
  @if $direction == 'down' {
    @include responsive.breakpoint-down($breakpoint) {
      display: none !important;
    }
  } @else if $direction == 'up' {
    @include responsive.breakpoint-up($breakpoint) {
      display: none !important;
    }
  } @else {
    @error "Direction must be 'up' or 'down'";
  }
} 